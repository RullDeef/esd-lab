\chapter{Теоретический раздел}

\section{Алгоритм поиска в глубину в графах И-ИЛИ}

В нем определяется самое левое дерево решения (возможно не оптимальное). Если не глубокий, то его хорошо использовать. Используется идея стека и идея списков. Вводятся следующие списки:

\begin{enumerate}
    \item Список открытых вершин.
    \item Список закрытых вершин.
    \item Список открытых и закрытых правил.
    \item В методе поиска в глубину - список запрещенных вершин.
    \item Список всех правил.
\end{enumerate}

Разработаем класс, полями которого объявляем эти списки, вводим два флага -- есть решение,  и нет решения. В конструктор класса передаем список базы правил, целевую вершину, массив заданных входных вершин. В конструкторе входные вершины записываем в список закрытых вершин, целевую вершину помещаем в голову стека (который является списком открытых вершин). Флаги решения выставляем в единицу. Все вершины имеют флаги 0, а флаги входных вершин устанавливаем в 1.

Можно выделить 4 метода:

\begin{enumerate}
    \item Потомки. В этом методе определяем первое правило, которое раскрывает текущую подцель. Возвращает признак нахождения правила (0 или 1).
    \item Поиск - основной метод, вызывает все остальные методы.
    \item Бэктрекинг - в нем отсекаются запрещенные вершины и правила.
    \item Разметка - в нем формируется список закрытых правил, составляющих дерево решения и список доказанных/закрытых вершин.
\end{enumerate}
    
\section{Алгоритм определения потомков}

В этом методе по принципу стека формируются списки открытых вершин и правил. Текущая подцель выбирается из головы стека открытых вершин. В цикле по базе правил определяем первое правило, выходная вершина которого совпадает с подцелью, то есть раскрывает эту вершину. Номер правила записываем в голову стека открытых правил. Следующая задача -- сформировать новые подцели и записать в стек открытых вершин. Для этого надо определить, какие вершины выбранного правила (из входных) не входят в закрытые (сначала это заданные входные вершины). Эти вершины добавляем в голову стека вершин. А в процессе определения таких вершин флаги входных вершин текущего правила (которое входит в список закрытых) ставим в единицу и никуда не пишем. Условие выбора правила: выходная вершина совпадает с подцелью и метка правила не выставлена (мы выбираем его первый раз) и дополнительно можно проверять, что выходная вершина правила не является запрещенной. Метку выбранного правила надо поставить в единицу.

Проверяем следующее -- если все входные вершины правила попали в закрытые, то новых подцелей нет, и если выходная вершина является целевой, то флаг решения в 0 (мы нашли решение). Иначе, если выход -- нецелевая вершина, то вызываем разметку.

В разметки методе выходную вершину доказанного правила надо переписать в закрытые и удалить из открытых.

\section{Алгоритм возврата}

В этом случае потомков мы не нашли -- функция потомков возвратит 0. Это значит, что текущая подцель должна объявляться как запрещенная вершина. Само правило тоже должно быть запрещено. Мы должны при этом текущую подцель удалить из стека открытых правил, правило из головы стека объявить запрещенным, удалить и поместить в запрещенные. Помимо этого надо из стека удалить все подцели, которые являлись входными вершинами запрещенного правила. После этого снова вызываем метод потомки -- ищем альтернативный путь для последней вершины. И аналогично -- если альтернативы нет, то снова возврат.

Если в результате получаем, что в стеке открытых вершин осталась только целевая вершина, а потомков нет, то флаг нет решения сбрасываем в 0.

\section{Алгоритм разметки. Построение дерева решения. Формирование закрытых правил}

В разметке нужно подниматься снизу вверх. Последнее правило становится доказанным, мы его переносим в закрытые правила. В список закрытых вершин добавляем нашу подцель и удаляем их из стека открытых вершин и правил. Можно поставить флаг у этой вершины. Если выходная вершина целевая, то флаг fy = 0.

На следующем шаге в цикле мы должны вершину, которую мы доказали, найти в списке входных вершин правила из головы стека, флаг ее поставить в единицу и проверить, выполняется ли покрытие ее входов закрытыми вершинами. Если выполняется, то на следующий шаг цилка. Если покрытия нет -- выход из цикла.

В разметке введем флаг, который означает что модуль доказан (флаг1).

\begin{verbatim}    
1. Пока fy == 1 и флаг1 == 1:
2. Метку правила из головы стека ставим в доказанную
3. Флаг вершины подцели ставим в доказанную
4. Флаг выходной вершины модуля тоже в единицу
5. Если выходная вершина доказанного правила == цель, то fy = 0
6. Иначе:
7. Правило из головы стека открытых правил пишем в закрытые и
   удаляем из списка открытых
8. Вершину из списка открытых вершин перенести в закрытые, а
   потом удалить
9. В новом правиле из головы стека среди входных определить
   вершину, флаг ее поставить в единицу и проверить, все ли
   входные вершины доказаны.
10. Если не доказаны, то флаг1 = 0
\end{verbatim}
